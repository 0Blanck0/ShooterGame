<html>
<head>
<title>prepare.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #629755; font-style: italic;}
.s1 { color: #a9b7c6;}
.s2 { color: #808080;}
.s3 { color: #cc7832;}
.s4 { color: #6a8759;}
.s5 { color: #6897bb;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
prepare.py</font>
</center></td></tr></table>
<pre><span class="s0">&quot;&quot;&quot;Prepares a distribution for installation 
&quot;&quot;&quot;</span>

<span class="s2"># The following comment should be removed at some point in the future.</span>
<span class="s2"># mypy: strict-optional=False</span>

<span class="s3">import </span><span class="s1">logging</span>
<span class="s3">import </span><span class="s1">mimetypes</span>
<span class="s3">import </span><span class="s1">os</span>
<span class="s3">import </span><span class="s1">shutil</span>
<span class="s3">import </span><span class="s1">sys</span>

<span class="s3">from </span><span class="s1">pip._vendor </span><span class="s3">import </span><span class="s1">requests</span>
<span class="s3">from </span><span class="s1">pip._vendor.six </span><span class="s3">import </span><span class="s1">PY2</span>

<span class="s3">from </span><span class="s1">pip._internal.distributions </span><span class="s3">import </span><span class="s1">(</span>
    <span class="s1">make_distribution_for_install_requirement</span><span class="s3">,</span>
<span class="s1">)</span>
<span class="s3">from </span><span class="s1">pip._internal.distributions.installed </span><span class="s3">import </span><span class="s1">InstalledDistribution</span>
<span class="s3">from </span><span class="s1">pip._internal.exceptions </span><span class="s3">import </span><span class="s1">(</span>
    <span class="s1">DirectoryUrlHashUnsupported</span><span class="s3">,</span>
    <span class="s1">HashMismatch</span><span class="s3">,</span>
    <span class="s1">HashUnpinned</span><span class="s3">,</span>
    <span class="s1">InstallationError</span><span class="s3">,</span>
    <span class="s1">PreviousBuildDirError</span><span class="s3">,</span>
    <span class="s1">VcsHashUnsupported</span><span class="s3">,</span>
<span class="s1">)</span>
<span class="s3">from </span><span class="s1">pip._internal.utils.filesystem </span><span class="s3">import </span><span class="s1">copy2_fixed</span>
<span class="s3">from </span><span class="s1">pip._internal.utils.hashes </span><span class="s3">import </span><span class="s1">MissingHashes</span>
<span class="s3">from </span><span class="s1">pip._internal.utils.logging </span><span class="s3">import </span><span class="s1">indent_log</span>
<span class="s3">from </span><span class="s1">pip._internal.utils.marker_files </span><span class="s3">import </span><span class="s1">write_delete_marker_file</span>
<span class="s3">from </span><span class="s1">pip._internal.utils.misc </span><span class="s3">import </span><span class="s1">(</span>
    <span class="s1">ask_path_exists</span><span class="s3">,</span>
    <span class="s1">backup_dir</span><span class="s3">,</span>
    <span class="s1">display_path</span><span class="s3">,</span>
    <span class="s1">hide_url</span><span class="s3">,</span>
    <span class="s1">path_to_display</span><span class="s3">,</span>
    <span class="s1">rmtree</span><span class="s3">,</span>
<span class="s1">)</span>
<span class="s3">from </span><span class="s1">pip._internal.utils.temp_dir </span><span class="s3">import </span><span class="s1">TempDirectory</span>
<span class="s3">from </span><span class="s1">pip._internal.utils.typing </span><span class="s3">import </span><span class="s1">MYPY_CHECK_RUNNING</span>
<span class="s3">from </span><span class="s1">pip._internal.utils.unpacking </span><span class="s3">import </span><span class="s1">unpack_file</span>
<span class="s3">from </span><span class="s1">pip._internal.vcs </span><span class="s3">import </span><span class="s1">vcs</span>

<span class="s3">if </span><span class="s1">MYPY_CHECK_RUNNING:</span>
    <span class="s3">from </span><span class="s1">typing </span><span class="s3">import </span><span class="s1">(</span>
        <span class="s1">Callable</span><span class="s3">, </span><span class="s1">List</span><span class="s3">, </span><span class="s1">Optional</span><span class="s3">, </span><span class="s1">Tuple</span><span class="s3">,</span>
    <span class="s1">)</span>

    <span class="s3">from </span><span class="s1">mypy_extensions </span><span class="s3">import </span><span class="s1">TypedDict</span>

    <span class="s3">from </span><span class="s1">pip._internal.distributions </span><span class="s3">import </span><span class="s1">AbstractDistribution</span>
    <span class="s3">from </span><span class="s1">pip._internal.index.package_finder </span><span class="s3">import </span><span class="s1">PackageFinder</span>
    <span class="s3">from </span><span class="s1">pip._internal.models.link </span><span class="s3">import </span><span class="s1">Link</span>
    <span class="s3">from </span><span class="s1">pip._internal.network.download </span><span class="s3">import </span><span class="s1">Downloader</span>
    <span class="s3">from </span><span class="s1">pip._internal.req.req_install </span><span class="s3">import </span><span class="s1">InstallRequirement</span>
    <span class="s3">from </span><span class="s1">pip._internal.req.req_tracker </span><span class="s3">import </span><span class="s1">RequirementTracker</span>
    <span class="s3">from </span><span class="s1">pip._internal.utils.hashes </span><span class="s3">import </span><span class="s1">Hashes</span>

    <span class="s3">if </span><span class="s1">PY2:</span>
        <span class="s1">CopytreeKwargs = TypedDict(</span>
            <span class="s4">'CopytreeKwargs'</span><span class="s3">,</span>
            <span class="s1">{</span>
                <span class="s4">'ignore'</span><span class="s1">: Callable[[str</span><span class="s3">, </span><span class="s1">List[str]]</span><span class="s3">, </span><span class="s1">List[str]]</span><span class="s3">,</span>
                <span class="s4">'symlinks'</span><span class="s1">: bool</span><span class="s3">,</span>
            <span class="s1">}</span><span class="s3">,</span>
            <span class="s1">total=</span><span class="s3">False,</span>
        <span class="s1">)</span>
    <span class="s3">else</span><span class="s1">:</span>
        <span class="s1">CopytreeKwargs = TypedDict(</span>
            <span class="s4">'CopytreeKwargs'</span><span class="s3">,</span>
            <span class="s1">{</span>
                <span class="s4">'copy_function'</span><span class="s1">: Callable[[str</span><span class="s3">, </span><span class="s1">str]</span><span class="s3">, None</span><span class="s1">]</span><span class="s3">,</span>
                <span class="s4">'ignore'</span><span class="s1">: Callable[[str</span><span class="s3">, </span><span class="s1">List[str]]</span><span class="s3">, </span><span class="s1">List[str]]</span><span class="s3">,</span>
                <span class="s4">'ignore_dangling_symlinks'</span><span class="s1">: bool</span><span class="s3">,</span>
                <span class="s4">'symlinks'</span><span class="s1">: bool</span><span class="s3">,</span>
            <span class="s1">}</span><span class="s3">,</span>
            <span class="s1">total=</span><span class="s3">False,</span>
        <span class="s1">)</span>

<span class="s1">logger = logging.getLogger(__name__)</span>


<span class="s3">def </span><span class="s1">_get_prepared_distribution(</span>
        <span class="s1">req</span><span class="s3">,  </span><span class="s2"># type: InstallRequirement</span>
        <span class="s1">req_tracker</span><span class="s3">,  </span><span class="s2"># type: RequirementTracker</span>
        <span class="s1">finder</span><span class="s3">,  </span><span class="s2"># type: PackageFinder</span>
        <span class="s1">build_isolation  </span><span class="s2"># type: bool</span>
<span class="s1">):</span>
    <span class="s2"># type: (...) -&gt; AbstractDistribution</span>
    <span class="s0">&quot;&quot;&quot;Prepare a distribution for installation. 
    &quot;&quot;&quot;</span>
    <span class="s1">abstract_dist = make_distribution_for_install_requirement(req)</span>
    <span class="s3">with </span><span class="s1">req_tracker.track(req):</span>
        <span class="s1">abstract_dist.prepare_distribution_metadata(finder</span><span class="s3">, </span><span class="s1">build_isolation)</span>
    <span class="s3">return </span><span class="s1">abstract_dist</span>


<span class="s3">def </span><span class="s1">unpack_vcs_link(link</span><span class="s3">, </span><span class="s1">location):</span>
    <span class="s2"># type: (Link, str) -&gt; None</span>
    <span class="s1">vcs_backend = vcs.get_backend_for_scheme(link.scheme)</span>
    <span class="s3">assert </span><span class="s1">vcs_backend </span><span class="s3">is not None</span>
    <span class="s1">vcs_backend.unpack(location</span><span class="s3">, </span><span class="s1">url=hide_url(link.url))</span>


<span class="s3">def </span><span class="s1">_copy_file(filename</span><span class="s3">, </span><span class="s1">location</span><span class="s3">, </span><span class="s1">link):</span>
    <span class="s2"># type: (str, str, Link) -&gt; None</span>
    <span class="s1">copy = </span><span class="s3">True</span>
    <span class="s1">download_location = os.path.join(location</span><span class="s3">, </span><span class="s1">link.filename)</span>
    <span class="s3">if </span><span class="s1">os.path.exists(download_location):</span>
        <span class="s1">response = ask_path_exists(</span>
            <span class="s4">'The file {} exists. (i)gnore, (w)ipe, (b)ackup, (a)abort'</span><span class="s1">.format(</span>
                <span class="s1">display_path(download_location)</span>
            <span class="s1">)</span><span class="s3">,</span>
            <span class="s1">(</span><span class="s4">'i'</span><span class="s3">, </span><span class="s4">'w'</span><span class="s3">, </span><span class="s4">'b'</span><span class="s3">, </span><span class="s4">'a'</span><span class="s1">)</span><span class="s3">,</span>
        <span class="s1">)</span>
        <span class="s3">if </span><span class="s1">response == </span><span class="s4">'i'</span><span class="s1">:</span>
            <span class="s1">copy = </span><span class="s3">False</span>
        <span class="s3">elif </span><span class="s1">response == </span><span class="s4">'w'</span><span class="s1">:</span>
            <span class="s1">logger.warning(</span><span class="s4">'Deleting %s'</span><span class="s3">, </span><span class="s1">display_path(download_location))</span>
            <span class="s1">os.remove(download_location)</span>
        <span class="s3">elif </span><span class="s1">response == </span><span class="s4">'b'</span><span class="s1">:</span>
            <span class="s1">dest_file = backup_dir(download_location)</span>
            <span class="s1">logger.warning(</span>
                <span class="s4">'Backing up %s to %s'</span><span class="s3">,</span>
                <span class="s1">display_path(download_location)</span><span class="s3">,</span>
                <span class="s1">display_path(dest_file)</span><span class="s3">,</span>
            <span class="s1">)</span>
            <span class="s1">shutil.move(download_location</span><span class="s3">, </span><span class="s1">dest_file)</span>
        <span class="s3">elif </span><span class="s1">response == </span><span class="s4">'a'</span><span class="s1">:</span>
            <span class="s1">sys.exit(-</span><span class="s5">1</span><span class="s1">)</span>
    <span class="s3">if </span><span class="s1">copy:</span>
        <span class="s1">shutil.copy(filename</span><span class="s3">, </span><span class="s1">download_location)</span>
        <span class="s1">logger.info(</span><span class="s4">'Saved %s'</span><span class="s3">, </span><span class="s1">display_path(download_location))</span>


<span class="s3">def </span><span class="s1">unpack_http_url(</span>
    <span class="s1">link</span><span class="s3">,  </span><span class="s2"># type: Link</span>
    <span class="s1">location</span><span class="s3">,  </span><span class="s2"># type: str</span>
    <span class="s1">downloader</span><span class="s3">,  </span><span class="s2"># type: Downloader</span>
    <span class="s1">download_dir=</span><span class="s3">None,  </span><span class="s2"># type: Optional[str]</span>
    <span class="s1">hashes=</span><span class="s3">None,  </span><span class="s2"># type: Optional[Hashes]</span>
<span class="s1">):</span>
    <span class="s2"># type: (...) -&gt; str</span>
    <span class="s1">temp_dir = TempDirectory(kind=</span><span class="s4">&quot;unpack&quot;</span><span class="s3">, </span><span class="s1">globally_managed=</span><span class="s3">True</span><span class="s1">)</span>
    <span class="s2"># If a download dir is specified, is the file already downloaded there?</span>
    <span class="s1">already_downloaded_path = </span><span class="s3">None</span>
    <span class="s3">if </span><span class="s1">download_dir:</span>
        <span class="s1">already_downloaded_path = _check_download_dir(</span>
            <span class="s1">link</span><span class="s3">, </span><span class="s1">download_dir</span><span class="s3">, </span><span class="s1">hashes</span>
        <span class="s1">)</span>

    <span class="s3">if </span><span class="s1">already_downloaded_path:</span>
        <span class="s1">from_path = already_downloaded_path</span>
        <span class="s1">content_type = mimetypes.guess_type(from_path)[</span><span class="s5">0</span><span class="s1">]</span>
    <span class="s3">else</span><span class="s1">:</span>
        <span class="s2"># let's download to a tmp dir</span>
        <span class="s1">from_path</span><span class="s3">, </span><span class="s1">content_type = _download_http_url(</span>
            <span class="s1">link</span><span class="s3">, </span><span class="s1">downloader</span><span class="s3">, </span><span class="s1">temp_dir.path</span><span class="s3">, </span><span class="s1">hashes</span>
        <span class="s1">)</span>

    <span class="s2"># unpack the archive to the build dir location. even when only</span>
    <span class="s2"># downloading archives, they have to be unpacked to parse dependencies</span>
    <span class="s1">unpack_file(from_path</span><span class="s3">, </span><span class="s1">location</span><span class="s3">, </span><span class="s1">content_type)</span>

    <span class="s3">return </span><span class="s1">from_path</span>


<span class="s3">def </span><span class="s1">_copy2_ignoring_special_files(src</span><span class="s3">, </span><span class="s1">dest):</span>
    <span class="s2"># type: (str, str) -&gt; None</span>
    <span class="s0">&quot;&quot;&quot;Copying special files is not supported, but as a convenience to users 
    we skip errors copying them. This supports tools that may create e.g. 
    socket files in the project source directory. 
    &quot;&quot;&quot;</span>
    <span class="s3">try</span><span class="s1">:</span>
        <span class="s1">copy2_fixed(src</span><span class="s3">, </span><span class="s1">dest)</span>
    <span class="s3">except </span><span class="s1">shutil.SpecialFileError </span><span class="s3">as </span><span class="s1">e:</span>
        <span class="s2"># SpecialFileError may be raised due to either the source or</span>
        <span class="s2"># destination. If the destination was the cause then we would actually</span>
        <span class="s2"># care, but since the destination directory is deleted prior to</span>
        <span class="s2"># copy we ignore all of them assuming it is caused by the source.</span>
        <span class="s1">logger.warning(</span>
            <span class="s4">&quot;Ignoring special file error '%s' encountered copying %s to %s.&quot;</span><span class="s3">,</span>
            <span class="s1">str(e)</span><span class="s3">,</span>
            <span class="s1">path_to_display(src)</span><span class="s3">,</span>
            <span class="s1">path_to_display(dest)</span><span class="s3">,</span>
        <span class="s1">)</span>


<span class="s3">def </span><span class="s1">_copy_source_tree(source</span><span class="s3">, </span><span class="s1">target):</span>
    <span class="s2"># type: (str, str) -&gt; None</span>
    <span class="s3">def </span><span class="s1">ignore(d</span><span class="s3">, </span><span class="s1">names):</span>
        <span class="s2"># type: (str, List[str]) -&gt; List[str]</span>
        <span class="s2"># Pulling in those directories can potentially be very slow,</span>
        <span class="s2"># exclude the following directories if they appear in the top</span>
        <span class="s2"># level dir (and only it).</span>
        <span class="s2"># See discussion at https://github.com/pypa/pip/pull/6770</span>
        <span class="s3">return </span><span class="s1">[</span><span class="s4">'.tox'</span><span class="s3">, </span><span class="s4">'.nox'</span><span class="s1">] </span><span class="s3">if </span><span class="s1">d == source </span><span class="s3">else </span><span class="s1">[]</span>

    <span class="s1">kwargs = dict(ignore=ignore</span><span class="s3">, </span><span class="s1">symlinks=</span><span class="s3">True</span><span class="s1">)  </span><span class="s2"># type: CopytreeKwargs</span>

    <span class="s3">if not </span><span class="s1">PY2:</span>
        <span class="s2"># Python 2 does not support copy_function, so we only ignore</span>
        <span class="s2"># errors on special file copy in Python 3.</span>
        <span class="s1">kwargs[</span><span class="s4">'copy_function'</span><span class="s1">] = _copy2_ignoring_special_files</span>

    <span class="s1">shutil.copytree(source</span><span class="s3">, </span><span class="s1">target</span><span class="s3">, </span><span class="s1">**kwargs)</span>


<span class="s3">def </span><span class="s1">unpack_file_url(</span>
    <span class="s1">link</span><span class="s3">,  </span><span class="s2"># type: Link</span>
    <span class="s1">location</span><span class="s3">,  </span><span class="s2"># type: str</span>
    <span class="s1">download_dir=</span><span class="s3">None,  </span><span class="s2"># type: Optional[str]</span>
    <span class="s1">hashes=</span><span class="s3">None  </span><span class="s2"># type: Optional[Hashes]</span>
<span class="s1">):</span>
    <span class="s2"># type: (...) -&gt; Optional[str]</span>
    <span class="s0">&quot;&quot;&quot;Unpack link into location. 
    &quot;&quot;&quot;</span>
    <span class="s1">link_path = link.file_path</span>
    <span class="s2"># If it's a url to a local directory</span>
    <span class="s3">if </span><span class="s1">link.is_existing_dir():</span>
        <span class="s3">if </span><span class="s1">os.path.isdir(location):</span>
            <span class="s1">rmtree(location)</span>
        <span class="s1">_copy_source_tree(link_path</span><span class="s3">, </span><span class="s1">location)</span>
        <span class="s3">return None</span>

    <span class="s2"># If a download dir is specified, is the file already there and valid?</span>
    <span class="s1">already_downloaded_path = </span><span class="s3">None</span>
    <span class="s3">if </span><span class="s1">download_dir:</span>
        <span class="s1">already_downloaded_path = _check_download_dir(</span>
            <span class="s1">link</span><span class="s3">, </span><span class="s1">download_dir</span><span class="s3">, </span><span class="s1">hashes</span>
        <span class="s1">)</span>

    <span class="s3">if </span><span class="s1">already_downloaded_path:</span>
        <span class="s1">from_path = already_downloaded_path</span>
    <span class="s3">else</span><span class="s1">:</span>
        <span class="s1">from_path = link_path</span>

    <span class="s2"># If --require-hashes is off, `hashes` is either empty, the</span>
    <span class="s2"># link's embedded hash, or MissingHashes; it is required to</span>
    <span class="s2"># match. If --require-hashes is on, we are satisfied by any</span>
    <span class="s2"># hash in `hashes` matching: a URL-based or an option-based</span>
    <span class="s2"># one; no internet-sourced hash will be in `hashes`.</span>
    <span class="s3">if </span><span class="s1">hashes:</span>
        <span class="s1">hashes.check_against_path(from_path)</span>

    <span class="s1">content_type = mimetypes.guess_type(from_path)[</span><span class="s5">0</span><span class="s1">]</span>

    <span class="s2"># unpack the archive to the build dir location. even when only downloading</span>
    <span class="s2"># archives, they have to be unpacked to parse dependencies</span>
    <span class="s1">unpack_file(from_path</span><span class="s3">, </span><span class="s1">location</span><span class="s3">, </span><span class="s1">content_type)</span>

    <span class="s3">return </span><span class="s1">from_path</span>


<span class="s3">def </span><span class="s1">unpack_url(</span>
    <span class="s1">link</span><span class="s3">,  </span><span class="s2"># type: Link</span>
    <span class="s1">location</span><span class="s3">,  </span><span class="s2"># type: str</span>
    <span class="s1">downloader</span><span class="s3">,  </span><span class="s2"># type: Downloader</span>
    <span class="s1">download_dir=</span><span class="s3">None,  </span><span class="s2"># type: Optional[str]</span>
    <span class="s1">hashes=</span><span class="s3">None,  </span><span class="s2"># type: Optional[Hashes]</span>
<span class="s1">):</span>
    <span class="s2"># type: (...) -&gt; Optional[str]</span>
    <span class="s0">&quot;&quot;&quot;Unpack link into location, downloading if required. 
 
    :param hashes: A Hashes object, one of whose embedded hashes must match, 
        or HashMismatch will be raised. If the Hashes is empty, no matches are 
        required, and unhashable types of requirements (like VCS ones, which 
        would ordinarily raise HashUnsupported) are allowed. 
    &quot;&quot;&quot;</span>
    <span class="s2"># non-editable vcs urls</span>
    <span class="s3">if </span><span class="s1">link.is_vcs:</span>
        <span class="s1">unpack_vcs_link(link</span><span class="s3">, </span><span class="s1">location)</span>
        <span class="s3">return None</span>

    <span class="s2"># file urls</span>
    <span class="s3">elif </span><span class="s1">link.is_file:</span>
        <span class="s3">return </span><span class="s1">unpack_file_url(link</span><span class="s3">, </span><span class="s1">location</span><span class="s3">, </span><span class="s1">download_dir</span><span class="s3">, </span><span class="s1">hashes=hashes)</span>

    <span class="s2"># http urls</span>
    <span class="s3">else</span><span class="s1">:</span>
        <span class="s3">return </span><span class="s1">unpack_http_url(</span>
            <span class="s1">link</span><span class="s3">,</span>
            <span class="s1">location</span><span class="s3">,</span>
            <span class="s1">downloader</span><span class="s3">,</span>
            <span class="s1">download_dir</span><span class="s3">,</span>
            <span class="s1">hashes=hashes</span><span class="s3">,</span>
        <span class="s1">)</span>


<span class="s3">def </span><span class="s1">_download_http_url(</span>
    <span class="s1">link</span><span class="s3">,  </span><span class="s2"># type: Link</span>
    <span class="s1">downloader</span><span class="s3">,  </span><span class="s2"># type: Downloader</span>
    <span class="s1">temp_dir</span><span class="s3">,  </span><span class="s2"># type: str</span>
    <span class="s1">hashes</span><span class="s3">,  </span><span class="s2"># type: Optional[Hashes]</span>
<span class="s1">):</span>
    <span class="s2"># type: (...) -&gt; Tuple[str, str]</span>
    <span class="s0">&quot;&quot;&quot;Download link url into temp_dir using provided session&quot;&quot;&quot;</span>
    <span class="s1">download = downloader(link)</span>

    <span class="s1">file_path = os.path.join(temp_dir</span><span class="s3">, </span><span class="s1">download.filename)</span>
    <span class="s3">with </span><span class="s1">open(file_path</span><span class="s3">, </span><span class="s4">'wb'</span><span class="s1">) </span><span class="s3">as </span><span class="s1">content_file:</span>
        <span class="s3">for </span><span class="s1">chunk </span><span class="s3">in </span><span class="s1">download.chunks:</span>
            <span class="s1">content_file.write(chunk)</span>

    <span class="s3">if </span><span class="s1">hashes:</span>
        <span class="s1">hashes.check_against_path(file_path)</span>

    <span class="s3">return </span><span class="s1">file_path</span><span class="s3">, </span><span class="s1">download.response.headers.get(</span><span class="s4">'content-type'</span><span class="s3">, </span><span class="s4">''</span><span class="s1">)</span>


<span class="s3">def </span><span class="s1">_check_download_dir(link</span><span class="s3">, </span><span class="s1">download_dir</span><span class="s3">, </span><span class="s1">hashes):</span>
    <span class="s2"># type: (Link, str, Optional[Hashes]) -&gt; Optional[str]</span>
    <span class="s0">&quot;&quot;&quot; Check download_dir for previously downloaded file with correct hash 
        If a correct file is found return its path else None 
    &quot;&quot;&quot;</span>
    <span class="s1">download_path = os.path.join(download_dir</span><span class="s3">, </span><span class="s1">link.filename)</span>

    <span class="s3">if not </span><span class="s1">os.path.exists(download_path):</span>
        <span class="s3">return None</span>

    <span class="s2"># If already downloaded, does its hash match?</span>
    <span class="s1">logger.info(</span><span class="s4">'File was already downloaded %s'</span><span class="s3">, </span><span class="s1">download_path)</span>
    <span class="s3">if </span><span class="s1">hashes:</span>
        <span class="s3">try</span><span class="s1">:</span>
            <span class="s1">hashes.check_against_path(download_path)</span>
        <span class="s3">except </span><span class="s1">HashMismatch:</span>
            <span class="s1">logger.warning(</span>
                <span class="s4">'Previously-downloaded file %s has bad hash. '</span>
                <span class="s4">'Re-downloading.'</span><span class="s3">,</span>
                <span class="s1">download_path</span>
            <span class="s1">)</span>
            <span class="s1">os.unlink(download_path)</span>
            <span class="s3">return None</span>
    <span class="s3">return </span><span class="s1">download_path</span>


<span class="s3">class </span><span class="s1">RequirementPreparer(object):</span>
    <span class="s0">&quot;&quot;&quot;Prepares a Requirement 
    &quot;&quot;&quot;</span>

    <span class="s3">def </span><span class="s1">__init__(</span>
        <span class="s1">self</span><span class="s3">,</span>
        <span class="s1">build_dir</span><span class="s3">,  </span><span class="s2"># type: str</span>
        <span class="s1">download_dir</span><span class="s3">,  </span><span class="s2"># type: Optional[str]</span>
        <span class="s1">src_dir</span><span class="s3">,  </span><span class="s2"># type: str</span>
        <span class="s1">wheel_download_dir</span><span class="s3">,  </span><span class="s2"># type: Optional[str]</span>
        <span class="s1">build_isolation</span><span class="s3">,  </span><span class="s2"># type: bool</span>
        <span class="s1">req_tracker</span><span class="s3">,  </span><span class="s2"># type: RequirementTracker</span>
        <span class="s1">downloader</span><span class="s3">,  </span><span class="s2"># type: Downloader</span>
        <span class="s1">finder</span><span class="s3">,  </span><span class="s2"># type: PackageFinder</span>
        <span class="s1">require_hashes</span><span class="s3">,  </span><span class="s2"># type: bool</span>
        <span class="s1">use_user_site</span><span class="s3">,  </span><span class="s2"># type: bool</span>
    <span class="s1">):</span>
        <span class="s2"># type: (...) -&gt; None</span>
        <span class="s1">super(RequirementPreparer</span><span class="s3">, </span><span class="s1">self).__init__()</span>

        <span class="s1">self.src_dir = src_dir</span>
        <span class="s1">self.build_dir = build_dir</span>
        <span class="s1">self.req_tracker = req_tracker</span>
        <span class="s1">self.downloader = downloader</span>
        <span class="s1">self.finder = finder</span>

        <span class="s2"># Where still-packed archives should be written to. If None, they are</span>
        <span class="s2"># not saved, and are deleted immediately after unpacking.</span>
        <span class="s1">self.download_dir = download_dir</span>

        <span class="s2"># Where still-packed .whl files should be written to. If None, they are</span>
        <span class="s2"># written to the download_dir parameter. Separate to download_dir to</span>
        <span class="s2"># permit only keeping wheel archives for pip wheel.</span>
        <span class="s1">self.wheel_download_dir = wheel_download_dir</span>

        <span class="s2"># NOTE</span>
        <span class="s2"># download_dir and wheel_download_dir overlap semantically and may</span>
        <span class="s2"># be combined if we're willing to have non-wheel archives present in</span>
        <span class="s2"># the wheelhouse output by 'pip wheel'.</span>

        <span class="s2"># Is build isolation allowed?</span>
        <span class="s1">self.build_isolation = build_isolation</span>

        <span class="s2"># Should hash-checking be required?</span>
        <span class="s1">self.require_hashes = require_hashes</span>

        <span class="s2"># Should install in user site-packages?</span>
        <span class="s1">self.use_user_site = use_user_site</span>

    <span class="s1">@property</span>
    <span class="s3">def </span><span class="s1">_download_should_save(self):</span>
        <span class="s2"># type: () -&gt; bool</span>
        <span class="s3">if not </span><span class="s1">self.download_dir:</span>
            <span class="s3">return False</span>

        <span class="s3">if </span><span class="s1">os.path.exists(self.download_dir):</span>
            <span class="s3">return True</span>

        <span class="s1">logger.critical(</span><span class="s4">'Could not find download directory'</span><span class="s1">)</span>
        <span class="s3">raise </span><span class="s1">InstallationError(</span>
            <span class="s4">&quot;Could not find or access download directory '{}'&quot;</span>
            <span class="s1">.format(self.download_dir))</span>

    <span class="s3">def </span><span class="s1">prepare_linked_requirement(</span>
        <span class="s1">self</span><span class="s3">,</span>
        <span class="s1">req</span><span class="s3">,  </span><span class="s2"># type: InstallRequirement</span>
    <span class="s1">):</span>
        <span class="s2"># type: (...) -&gt; AbstractDistribution</span>
        <span class="s0">&quot;&quot;&quot;Prepare a requirement that would be obtained from req.link 
        &quot;&quot;&quot;</span>
        <span class="s3">assert </span><span class="s1">req.link</span>
        <span class="s1">link = req.link</span>

        <span class="s2"># TODO: Breakup into smaller functions</span>
        <span class="s3">if </span><span class="s1">link.scheme == </span><span class="s4">'file'</span><span class="s1">:</span>
            <span class="s1">path = link.file_path</span>
            <span class="s1">logger.info(</span><span class="s4">'Processing %s'</span><span class="s3">, </span><span class="s1">display_path(path))</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s1">logger.info(</span><span class="s4">'Collecting %s'</span><span class="s3">, </span><span class="s1">req.req </span><span class="s3">or </span><span class="s1">req)</span>

        <span class="s3">with </span><span class="s1">indent_log():</span>
            <span class="s2"># @@ if filesystem packages are not marked</span>
            <span class="s2"># editable in a req, a non deterministic error</span>
            <span class="s2"># occurs when the script attempts to unpack the</span>
            <span class="s2"># build directory</span>
            <span class="s2"># Since source_dir is only set for editable requirements.</span>
            <span class="s3">assert </span><span class="s1">req.source_dir </span><span class="s3">is None</span>
            <span class="s1">req.ensure_has_source_dir(self.build_dir)</span>
            <span class="s2"># If a checkout exists, it's unwise to keep going.  version</span>
            <span class="s2"># inconsistencies are logged later, but do not fail the</span>
            <span class="s2"># installation.</span>
            <span class="s2"># FIXME: this won't upgrade when there's an existing</span>
            <span class="s2"># package unpacked in `req.source_dir`</span>
            <span class="s3">if </span><span class="s1">os.path.exists(os.path.join(req.source_dir</span><span class="s3">, </span><span class="s4">'setup.py'</span><span class="s1">)):</span>
                <span class="s3">raise </span><span class="s1">PreviousBuildDirError(</span>
                    <span class="s4">&quot;pip can't proceed with requirements '{}' due to a&quot;</span>
                    <span class="s4">&quot; pre-existing build directory ({}). This is &quot;</span>
                    <span class="s4">&quot;likely due to a previous installation that failed&quot;</span>
                    <span class="s4">&quot;. pip is being responsible and not assuming it &quot;</span>
                    <span class="s4">&quot;can delete this. Please delete it and try again.&quot;</span>
                    <span class="s1">.format(req</span><span class="s3">, </span><span class="s1">req.source_dir)</span>
                <span class="s1">)</span>

            <span class="s2"># Now that we have the real link, we can tell what kind of</span>
            <span class="s2"># requirements we have and raise some more informative errors</span>
            <span class="s2"># than otherwise. (For example, we can raise VcsHashUnsupported</span>
            <span class="s2"># for a VCS URL rather than HashMissing.)</span>
            <span class="s3">if </span><span class="s1">self.require_hashes:</span>
                <span class="s2"># We could check these first 2 conditions inside</span>
                <span class="s2"># unpack_url and save repetition of conditions, but then</span>
                <span class="s2"># we would report less-useful error messages for</span>
                <span class="s2"># unhashable requirements, complaining that there's no</span>
                <span class="s2"># hash provided.</span>
                <span class="s3">if </span><span class="s1">link.is_vcs:</span>
                    <span class="s3">raise </span><span class="s1">VcsHashUnsupported()</span>
                <span class="s3">elif </span><span class="s1">link.is_existing_dir():</span>
                    <span class="s3">raise </span><span class="s1">DirectoryUrlHashUnsupported()</span>
                <span class="s3">if not </span><span class="s1">req.original_link </span><span class="s3">and not </span><span class="s1">req.is_pinned:</span>
                    <span class="s2"># Unpinned packages are asking for trouble when a new</span>
                    <span class="s2"># version is uploaded. This isn't a security check, but</span>
                    <span class="s2"># it saves users a surprising hash mismatch in the</span>
                    <span class="s2"># future.</span>
                    <span class="s2">#</span>
                    <span class="s2"># file:/// URLs aren't pinnable, so don't complain</span>
                    <span class="s2"># about them not being pinned.</span>
                    <span class="s3">raise </span><span class="s1">HashUnpinned()</span>

            <span class="s1">hashes = req.hashes(trust_internet=</span><span class="s3">not </span><span class="s1">self.require_hashes)</span>
            <span class="s3">if </span><span class="s1">self.require_hashes </span><span class="s3">and not </span><span class="s1">hashes:</span>
                <span class="s2"># Known-good hashes are missing for this requirement, so</span>
                <span class="s2"># shim it with a facade object that will provoke hash</span>
                <span class="s2"># computation and then raise a HashMissing exception</span>
                <span class="s2"># showing the user what the hash should be.</span>
                <span class="s1">hashes = MissingHashes()</span>

            <span class="s1">download_dir = self.download_dir</span>
            <span class="s3">if </span><span class="s1">link.is_wheel </span><span class="s3">and </span><span class="s1">self.wheel_download_dir:</span>
                <span class="s2"># when doing 'pip wheel` we download wheels to a</span>
                <span class="s2"># dedicated dir.</span>
                <span class="s1">download_dir = self.wheel_download_dir</span>

            <span class="s3">try</span><span class="s1">:</span>
                <span class="s1">local_path = unpack_url(</span>
                    <span class="s1">link</span><span class="s3">, </span><span class="s1">req.source_dir</span><span class="s3">, </span><span class="s1">self.downloader</span><span class="s3">, </span><span class="s1">download_dir</span><span class="s3">,</span>
                    <span class="s1">hashes=hashes</span><span class="s3">,</span>
                <span class="s1">)</span>
            <span class="s3">except </span><span class="s1">requests.HTTPError </span><span class="s3">as </span><span class="s1">exc:</span>
                <span class="s1">logger.critical(</span>
                    <span class="s4">'Could not install requirement %s because of error %s'</span><span class="s3">,</span>
                    <span class="s1">req</span><span class="s3">,</span>
                    <span class="s1">exc</span><span class="s3">,</span>
                <span class="s1">)</span>
                <span class="s3">raise </span><span class="s1">InstallationError(</span>
                    <span class="s4">'Could not install requirement {} because of HTTP '</span>
                    <span class="s4">'error {} for URL {}'</span><span class="s1">.format(req</span><span class="s3">, </span><span class="s1">exc</span><span class="s3">, </span><span class="s1">link)</span>
                <span class="s1">)</span>

            <span class="s2"># For use in later processing, preserve the file path on the</span>
            <span class="s2"># requirement.</span>
            <span class="s3">if </span><span class="s1">local_path:</span>
                <span class="s1">req.local_file_path = local_path</span>

            <span class="s3">if </span><span class="s1">link.is_wheel:</span>
                <span class="s3">if </span><span class="s1">download_dir:</span>
                    <span class="s2"># When downloading, we only unpack wheels to get</span>
                    <span class="s2"># metadata.</span>
                    <span class="s1">autodelete_unpacked = </span><span class="s3">True</span>
                <span class="s3">else</span><span class="s1">:</span>
                    <span class="s2"># When installing a wheel, we use the unpacked</span>
                    <span class="s2"># wheel.</span>
                    <span class="s1">autodelete_unpacked = </span><span class="s3">False</span>
            <span class="s3">else</span><span class="s1">:</span>
                <span class="s2"># We always delete unpacked sdists after pip runs.</span>
                <span class="s1">autodelete_unpacked = </span><span class="s3">True</span>
            <span class="s3">if </span><span class="s1">autodelete_unpacked:</span>
                <span class="s1">write_delete_marker_file(req.source_dir)</span>

            <span class="s1">abstract_dist = _get_prepared_distribution(</span>
                <span class="s1">req</span><span class="s3">, </span><span class="s1">self.req_tracker</span><span class="s3">, </span><span class="s1">self.finder</span><span class="s3">, </span><span class="s1">self.build_isolation</span><span class="s3">,</span>
            <span class="s1">)</span>

            <span class="s3">if </span><span class="s1">download_dir:</span>
                <span class="s3">if </span><span class="s1">link.is_existing_dir():</span>
                    <span class="s1">logger.info(</span><span class="s4">'Link is a directory, ignoring download_dir'</span><span class="s1">)</span>
                <span class="s3">elif </span><span class="s1">local_path </span><span class="s3">and not </span><span class="s1">os.path.exists(</span>
                    <span class="s1">os.path.join(download_dir</span><span class="s3">, </span><span class="s1">link.filename)</span>
                <span class="s1">):</span>
                    <span class="s1">_copy_file(local_path</span><span class="s3">, </span><span class="s1">download_dir</span><span class="s3">, </span><span class="s1">link)</span>

            <span class="s3">if </span><span class="s1">self._download_should_save:</span>
                <span class="s2"># Make a .zip of the source_dir we already created.</span>
                <span class="s3">if </span><span class="s1">link.is_vcs:</span>
                    <span class="s1">req.archive(self.download_dir)</span>
        <span class="s3">return </span><span class="s1">abstract_dist</span>

    <span class="s3">def </span><span class="s1">prepare_editable_requirement(</span>
        <span class="s1">self</span><span class="s3">,</span>
        <span class="s1">req</span><span class="s3">,  </span><span class="s2"># type: InstallRequirement</span>
    <span class="s1">):</span>
        <span class="s2"># type: (...) -&gt; AbstractDistribution</span>
        <span class="s0">&quot;&quot;&quot;Prepare an editable requirement 
        &quot;&quot;&quot;</span>
        <span class="s3">assert </span><span class="s1">req.editable</span><span class="s3">, </span><span class="s4">&quot;cannot prepare a non-editable req as editable&quot;</span>

        <span class="s1">logger.info(</span><span class="s4">'Obtaining %s'</span><span class="s3">, </span><span class="s1">req)</span>

        <span class="s3">with </span><span class="s1">indent_log():</span>
            <span class="s3">if </span><span class="s1">self.require_hashes:</span>
                <span class="s3">raise </span><span class="s1">InstallationError(</span>
                    <span class="s4">'The editable requirement {} cannot be installed when '</span>
                    <span class="s4">'requiring hashes, because there is no single file to '</span>
                    <span class="s4">'hash.'</span><span class="s1">.format(req)</span>
                <span class="s1">)</span>
            <span class="s1">req.ensure_has_source_dir(self.src_dir)</span>
            <span class="s1">req.update_editable(</span><span class="s3">not </span><span class="s1">self._download_should_save)</span>

            <span class="s1">abstract_dist = _get_prepared_distribution(</span>
                <span class="s1">req</span><span class="s3">, </span><span class="s1">self.req_tracker</span><span class="s3">, </span><span class="s1">self.finder</span><span class="s3">, </span><span class="s1">self.build_isolation</span><span class="s3">,</span>
            <span class="s1">)</span>

            <span class="s3">if </span><span class="s1">self._download_should_save:</span>
                <span class="s1">req.archive(self.download_dir)</span>
            <span class="s1">req.check_if_exists(self.use_user_site)</span>

        <span class="s3">return </span><span class="s1">abstract_dist</span>

    <span class="s3">def </span><span class="s1">prepare_installed_requirement(</span>
        <span class="s1">self</span><span class="s3">,</span>
        <span class="s1">req</span><span class="s3">,  </span><span class="s2"># type: InstallRequirement</span>
        <span class="s1">skip_reason  </span><span class="s2"># type: str</span>
    <span class="s1">):</span>
        <span class="s2"># type: (...) -&gt; AbstractDistribution</span>
        <span class="s0">&quot;&quot;&quot;Prepare an already-installed requirement 
        &quot;&quot;&quot;</span>
        <span class="s3">assert </span><span class="s1">req.satisfied_by</span><span class="s3">, </span><span class="s4">&quot;req should have been satisfied but isn't&quot;</span>
        <span class="s3">assert </span><span class="s1">skip_reason </span><span class="s3">is not None, </span><span class="s1">(</span>
            <span class="s4">&quot;did not get skip reason skipped but req.satisfied_by &quot;</span>
            <span class="s4">&quot;is set to {}&quot;</span><span class="s1">.format(req.satisfied_by)</span>
        <span class="s1">)</span>
        <span class="s1">logger.info(</span>
            <span class="s4">'Requirement %s: %s (%s)'</span><span class="s3">,</span>
            <span class="s1">skip_reason</span><span class="s3">, </span><span class="s1">req</span><span class="s3">, </span><span class="s1">req.satisfied_by.version</span>
        <span class="s1">)</span>
        <span class="s3">with </span><span class="s1">indent_log():</span>
            <span class="s3">if </span><span class="s1">self.require_hashes:</span>
                <span class="s1">logger.debug(</span>
                    <span class="s4">'Since it is already installed, we are trusting this '</span>
                    <span class="s4">'package without checking its hash. To ensure a '</span>
                    <span class="s4">'completely repeatable environment, install into an '</span>
                    <span class="s4">'empty virtualenv.'</span>
                <span class="s1">)</span>
            <span class="s1">abstract_dist = InstalledDistribution(req)</span>

        <span class="s3">return </span><span class="s1">abstract_dist</span>
</pre>
</body>
</html>